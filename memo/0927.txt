プログラム中で書かれている型とメモリの関係について
○僕らが解釈する数値と、メモリ上に置いてある値は必ずしも一致しません
　型には２つのいみがある
　　　①メモリ上の値をどう解釈するか
　　　②その型そのものがどれくらいのメモリを食いつぶすか

　人間はメモリ上にあるデータをそのままつかうことができない
　　　→データおよび(解釈【ビュー】)とせっとでやっとつかいものになる


【参照】について
　　ポインタみたいなものです←指し示しているのはアドレス
　　ただしポインタよりも使いたやすくできていて
　　普通に＊やー＞をつけなくても、普通の『値変数』と同様に使えます

　　int b=12
       int& a=b
      こうするとaとbと同じ場所をさし示しているため
　b++
　とかくと、aも１３となり、さらにa++とかくとbも１４になります

　参照のルール（ポインタと同じ役割ですがポインタよりルールが厳しい）
　　　　①宣言時にどこを参照するかが決まってないとダメ
　　　　　　（例外的にコンストラクタの初期化リストは許される）
　　　　　　　int& a;//だめ
　　　　②参照先の変更はできません
　　　　　int& a=d;
         a=c;//これはcの値をaにコピーしているだけ

　参照とポインタどっちを使えばいいの？
　　　　☆参照のほうが良い場面
　　　　　　①初期化時に参照先のアドレスが確定している場合
　　　　　　②参照先を最後まで変更しない事を保証できる場合

union（共用体）について
　　　共用体とは、要素それぞれが同じメモリを共有して使う型です
　　　めったに目にする型ではないですが、ハードに近い部分や
　　　古いコードではよく出てきます（メモリの内容をけちるため）
c++的な『型』について
　　std::vector<std::string これも一つの『型』です
       クラスと同じような扱いです

型と値のコピーについて
　　通常、同じ型どうしの=演算は値のコピーがおこなわれます
　　ここでいう値のコピーはメモリの内容をそっくりそのまま相手に
　　コピーします

int a[4]={1,2,3,4}
      int b[4];
     b=a;//なぜだめなのか
　　
　これはaが指し示しているのは配列の先頭アドレスで
　それをbにコピーしようとしている。つまり、アドレスの値を





で、ここでvecotrにつてですが
　　std::vector<int>a={1,2,3,4}
       std::vector<int> b;

       b=a
      これは、実はきちんとメモリの内容がこぴーされます
　　配列と違って、アドレスの受け渡しではなく内容がちゃんと
　　コピーされます。つまり構造体のような挙動になりますが

　　実は＝で代入していますが、これはvecotr の中に定義されている
　　＝演算子オーバーロードが内部メモリをコピーしてくれています

☆ゲーム用のtips
　　関数に『配列や構造体やvector 』　を渡す際は、できるだけ
　　参照渡しましょう



c++の中にはstlというものがあります
この中にでよく使用する型として
std::vector<t>
std**map<key,vakue>
があります

std::vector<t>は動的配列を表現します
動的配列というものは、固定長の配列違って後から配列のサイズ
変更できるものです

ｔと書いた部分に、動的配列の要素の型を入れることで
ｔ型の、動的配列を作ることができます

std::vector<int>←int型の動的配列
std::ctor<loat>←float型の動的配列

int a[4]
a={1,2,3,4,5}//ダメ

vector<int> b={1,2,3,4};
b.push_back(5);
b={1,2,3,4,5}//ok

なぜこんな動的配列が必要なのか
通常の配列は配列の要素数が最初っから決まってるときにしか
適用できない

ゲーム開始時点では、ステージの広さがわからない
ステージデータをロードして初めてステージの広さが分かる
そんな場合があります。そういう場合はマップデータを後からあ
拡張しないといけません→固定配列では力不足。そんな時に動的配列を
使用します


☆ゲーム用のtips
　　関数に『配列や構造体やvector 』　を渡す際は、できるだけ
　　参照渡しましょう

　　なぜか
　　　　引数で渡す場合は意味合い的には

　　　　引数の型　変数名=引数;

               と書ているのと同じです。intやfloatならせいぜい
　　　　４ばいとなので、このコストはそんなにおおきくありません

　　　　ところが構造体の場合はたいてい１６ばいととか、３２ばいととか
　　　　なんだったら、５１２ばいとや、もっと言うと何ｋｂになったりします
　　　　これの何がまずいのか
　
　　　　関数を呼び出すたびに、構造体のサイズ分のメモリが確保されてしましい
　　　　さらにメモリのコピーが発生します　１～２回なら問題ないのですが
　　　　たとえば３D座標の受け渡しなどは、ループ内で１００００回とか発生します
　　　　そうなると、５１２バイトのコピーは512000バイトのコピーコストになります

　　　　なお、アプリケーションの処理の重さに影響を与える順番で書くと
　　　　ロード＞＞メモリの確保＝メモリの内容コピーー＞それ以外の演算

　　　　→☆原則的には、関数に構造体（８ばいとを超える内容の物）を渡すときは
　　　　　　参照渡しにいしよう。ただし、ただの参照渡しだと副作用があるため
　　　　　　関数内部で引数の値を書き換えられないようにconst参照にしよう

c++では　　『保証する』という考え方が非常に大事で、そのために
　　　参照引数をconstにしたり、関数のお尻にconstをつけたりします
　　　こうすることで、
　　　参照引数は、内部で書き換えられないことでを保証し
　　　const関数のメンバ関数内部でメンバー変数の内容を書き換えない事を保証します

autoについて　　c#のvarみたいなもの
　　普通、変数を宣言するときには、intやfloatなどを指定します
　　もし,右辺値から『型』を推測可能な場合には、intやfloatではなく
　　autoと書けば、型をこんぱいらが推測して自動でintやfloatにしてくれます
　　このことから、autoを使うと、右辺値の型さえ確定してれば全部autoでok
   なんでautoみたいなのがあるかというと、プログラムを書いているうちに
　　『あ、これfloatのほうがいいな、全部変えよう』みたいなときに、変更箇所が
　　増えます。変更箇所が増えるとバグが増えます。

　　なので、型自体を右辺値にきめさせようという思想の中からうまれました。
　　
　　☆autoの注意点
　　　思った型になってないこともあるので、慣れないうちは変数にカーソルを合わせて
　　　型名を確認しよう
　　　autoといっても、型はコンパイル時確定されますので
　　　auto a=5;
          a=3.14f;
     とするとaは整数型のままなので、a=3になってしまいます
　　
　　　autoは＆などを引継ぎませんので、参照として扱いたい場合は
　　　auto& a=b;
      とします　例えば
　　　int c=3
      auto& b=c;
      auto a=b;//aはただのbのコピーになります
　　　この場合、aはただの値なので、cやbaの内容とは独立します
　　　よくあるのが
　　　for(auto e: array){
          ++e
     }
     この場合は、もとになった配列の内容は書き換えられない
autoを使ってほしい部分
　　　右辺値が確実に存在する場合
　　　①あとで型が変わりそうな場合
　　　②型の名前がやたら長い
　　　③型がやたらとややこしいとき←関数ポインタ等
　　　　　　関数ポインタは宣言void（＊ｆ）（引数）みたいにややこしいので
　　　　　　auto使ったほうが見栄えもいい。

charとwchar_tは明確に違う
プロジェクト→プロパティ→全般→文字セット
①マルチバイト→char*がデフォルト文字列を表す
②unicode→wchar_t*がデフォルト文字列を表す

①の時は
LoadGraph("○○。pig");
としなけばならない

文字列には、通常の文字列ワイド文字の二種類があります
通常の文字列リテラルが、char*で表せる""ダブルくうぉーとでok
ワイド文字列リテラルは、wchar_t*で表せる
　　　　　　　